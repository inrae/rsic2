#' Get PAR filename for a given scenario in a SIC project
#'
#' @inheritParams sic_run_export
#'
#' @return A [character] with the path of the PAR file
#' @noRd
#'
sic_get_par_filename <- function(cfg, scenario) {
  x <- read_xml(cfg$project$path)
  xPath <- sprintf("/Reseau/Flu[@nScenario=%d]/NomFicPar", scenario)
  file <- x %>% xml_find_first(xPath) %>% xml_text
  return(file.path(dirname(cfg$project$path), file))
}

#' Write a PAR file for SIC simulation
#'
#' Write inputs  in a PAR file respectively to \link{https://sic.g-eau.fr/Format-of-the-par-file}
#'
#' @inheritParams sic_run_fortran
#'
#' @return Nothing.
#' @export
#'
#' @examples
sic_write_par <- function(cfg, scenario, sicInputs) {

  if (is.null(attr(cfg, "config"))) {
    stop("`cfg` should be created with `loadConfig()`")
  }
  stopifnot(is.numeric(scenario),
            length(scenario) == 1,
            inherits(sicInputs, "SicInput") || inherits(sicInputs, "SicInputs"))
  if (inherits(sicInputs, "SicInput")) sicInputs <- merge(sicInputs)

  sParFileName = sic_get_par_filename(cfg, scenario)

  df = data.frame(C1 = "// PAR file for SIC",
                  C2 = "automatically generated by rsci2",
                  C3 = "",
                  stringsAsFactors = FALSE)
  i = 0
  for (input in sicInputs) {
    i = i + 1
    # Localisation
    if (is.null(input$locations)) {
      dfLoc <- NULL
    } else {
      dfLoc <- data.frame(C1 = paste0("L", i), C2 = input$locations, C3 = "", stringsAsFactors = FALSE)
    }
    if (is.data.frame(input$data)) {
      dfHeader <- data.frame(C1 = paste0("X", i), C2 = "LOI", C3 = ifelse(input$interpolated, "R", "E"))
      dfData <- cbind(rep(paste0("X", i), nrow(input$data)), input$data)
      names(dfData) <- names(df)
      dfData <- rbind(dfHeader, dfData)
    } else {
      dfData <- data.frame(C1 = paste0("X", i), C2 = input$data, C3 = "")
    }
    df = rbind(df, dfLoc, dfData)
  }
  write.table(df, file = sParFileName, col.names = F, row.names = F, sep = "\t", quote = F)
}

#' Create a SIC input for a PAR file
#'
#' @param x either a fixed input, a [numeric] vector of time in seconds,
#'          a [POSIXt] vector of time, a [matrix] or a [data.frame] with 2 columns (time and value)
#' @param values a [numeric] vector used if `x` is a vector of [numeric] or [POSIXt]
#' @param start a [POSIXt] indicating the start time to use as time zero in the simulation
#' @param locations input locations created with [SicLocation] or [SicLocations]
#' @param interpolated Interpolation mode `TRUE` for "ramp" mode and `FALSE` for "step" mode
#' @param ... used for S3 method compatibility
#'
#' @return A *SicInput* object which is a list with the following items:
#'
#' - `locations`: a [SicLocations] object
#' - `data`: [numeric], the fixed value, or [data.frame], the time series to apply to the locations
#' - `interpolated`: [logical], interpolation mode
#'
#' @rdname SicInput
#' @export
#'
#' @examples
SicInput <- function(x, ...) {
  UseMethod("SicInput", x)
}

#' @rdname SicInput
#' @export
SicInput.numeric <- function(x, values = NULL, locations, interpolated = TRUE, ...) {
  if (!(inherits(locations, "SicLocation") || inherits(locations, "SicLocations"))){
    stop("`locations` should be of class 'SicLocation' or 'SicLocations'")
  }
  if (is.null(values)) {
    if (length(x) != 1)
      stop("For a single value `x` should be of length 1")
    data <- x
  } else {
    if (length(x) != length(values))
      stop("Lenghts of `x` and `values`should be equal.")
    data <- data.frame(t = x,
                       v = values)
  }
  sicInput <- list(
    locations = locations,
    data = data,
    interpolated = interpolated
  )
  class(sicInput) <- c("SicInput", class(sicInput))
  return(sicInput)
}

#' @rdname SicInput
#' @export
SicInput.POSIXt <- function(x, values, start = NULL, ...) {
  if (is.null(start)) start = x[1]
  if (!inherits(start, "POSIXt"))
    stop("`start` should be of class 'POSIXt'.")

  # Conversion in seconds
  x <- as.numeric(difftime(x, start, units = "secs"))

  if (any(x < 0))
    stop("Negative time detected. Check the start time or the time series order.")

  SicInput(x, values, ...)
}

#' @rdname SicInput
#' @export
SicInput.data.frame <- function(x, ...) {
  SicInput(x[,1], x[, 2], ...)
}

#' @rdname SicInput
#' @export
SicInput.matrix <- function(x, ...) {
  SicInput(x[,1], x[, 2], ...)
}

#' Merge SicInput objects into a list
#'
#' @param x
#' @param y
#' @param ...
#'
#' @return A `SicInputs` object which is a list of [SicInput]
#' @export
#'
#' @examples
merge.SicInput <- function(x, y = NULL, ...) {
  sicInputs <- list(x, y, ...)
  sicInputs[sapply(sicInputs, is.null)] <- NULL
  class(sicInputs) <- c("SicInputs", class(sicInputs))
  return(sicInputs)
}

SicLocations <- function(...) {
  locations <- list(...)
  if (length(locations) == 1) locations <- locations[[1]]
  if(!is.list(locations)) stop("`locations` must be a list")
  l <- sapply(locations, SicLocation)
  class(l) <- c("SicLocations", class(l))
  return(l)
}

SicLocation <- function(location) {
  names(location) <- toupper(names(location))
  # Checks
  availLoc <- c("BF", "ND", "PR", "ST", "OUV", "SN", "PBF", "CAR")
  availCar <- c("Q", "Z", "KMin", "KMoy", "Inf", "CoteRadier", "Largeur",
                "Ouverture", "CoefQR", "SurverseHauteur", "CoefQSurverse",
                "TanAl", "CoefQT", "CoteAxe", "Rayon", "D", "JMax", "S1S2",
                "Decal", "Decrement", "CoteAmont")
  if (!is.list(location)) stop("Each `location` must be a list")
  if (!"CAR" %in% names(location)) stop("Each location should have at least an item 'CAR'")
  if (!any(names(location) %in% c("BF", "ND")))
    stop("a location should have at least an item 'BF' or 'ND'")
  dfIncompat <- expand.grid(c("BF", "SN", "PBF"), c("ND", "PR", "ST"))
  lapply(seq_len(nrow(dfIncompat)), function(i) {
    if (all(unlist(dfIncompat[i, ]) %in% names(location)))
      stop("These items can't be together in a location: ", paste(paste0("'", unlist(dfIncompat[i, ]), "'"), collapse = ", "))
  })
  if (any(names(location) %in% c("SN", "PBF")) & !"BF" %in% names(location))
    stop("Location with 'SN' or 'PBF' item should have an item 'BF'")
  # Create location string
  l <- lapply(names(location), function(objType) {
    if (!objType %in% availLoc) stop("Unknown location type: ", objType)
    if (objType == "CAR" && !location[[objType]] %in% availCar)
      stop("Value '", location[[objType]], "' of item 'CAR' unsupported. It should be one of: ",
           paste(paste0("'", availCar, "'"), sep = ", "))
    if (objType != "CAR" && !is.numeric(location[[objType]]))
      stop("Item '", objType, "' should be numeric.")
    return(paste(objType, location[[objType]], sep = "="))
  })
  s <- paste(unlist(l), collapse = "\t")
  class(s) <- c("SicLocation", class(s))
  return(s)
}
